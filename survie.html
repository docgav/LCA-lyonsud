<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCA Lyon Sud : Analyse de Survie</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        h1, h2, h3 { font-family: 'Roboto Slab', serif; }
        .hidden-section { display: none; }
        .visible-section { display: block; opacity: 1; transform: translateY(0); transition: opacity 0.5s ease-out, transform 0.5s ease-out; }
        .control-radio:checked + label { background-color: #67e8f9; border-color: #06b6d4; color: #0e7490; }
        .toggle-btn-active { background-color: #06b6d4; color: white; }
        .toggle-btn-inactive { background-color: #cbd5e1; color: #475569; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <header class="bg-white shadow-md">
        <div class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8 text-center">
            <h1 class="text-4xl font-bold text-slate-900">LCA Lyon Sud</h1>
            <p class="mt-2 text-xl text-slate-600">Outil Interactif sur l'Analyse de Survie</p>
        </div>
    </header>

    <main class="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8 space-y-12">
        <section id="data-visualization" class="bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold text-purple-700 border-b-2 border-purple-100 pb-2">1. Visualisation des données & Analyse à un temps T</h2>
            <p class="mt-4 text-slate-600">Dans une étude épidémiologique, on va souvent s’intéresser à l’effet d’un traitement ou d’un facteur de risque sur la survenue future d’un événement, comme le décès, ou un infarctus. On va ainsi par exemple randomiser nos patients entre un groupe traité et contrôle, et les suivres pendant une période de temps donnée, souvent définie à l’avance, jusqu’à une date de fin d’étude, que l’on appelle aussi date de point. Un patient peut se retrouver dans 3 cas différents: soit il a présenté l’événement d’intérêt lors de son suivi (X), soit il a été suivi pendant toute la durée de l’étude sans avoir présenté l’événement d’intérêt (>), soit il a été perdu de vue à un moment de l’étude (|). On pourrait choisir d’étudier la survenue de l’événement comme un critère binaire, oui ou non, pour comparer la proportion de patients ayant présenté l’événement entre le groupe traité et le groupe contrôle.Dans ce cas, cela nécessite obligatoirement de choisir un temps d’analyse. <br>Commencez par explorer les données simulées ci-dessous. Modifiez les paramètres pour voir l'impact du nombre de patients ou de l'efficacité du traitement sur les données générées.</p>
            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-slate-100 rounded-md">
                <div>
                    <label class="font-bold text-slate-700">Nombre de patients :</label>
                    <div class="flex flex-wrap gap-2 mt-2">
                        <input type="radio" name="n_patients" value="50" id="n50" class="control-radio hidden"><label for="n50" class="px-3 py-1 border rounded-md cursor-pointer transition">50</label>
                        <input type="radio" name="n_patients" value="200" id="n200" class="control-radio hidden" checked><label for="n200" class="px-3 py-1 border rounded-md cursor-pointer transition">200</label>
                        <input type="radio" name="n_patients" value="500" id="n500" class="control-radio hidden"><label for="n500" class="px-3 py-1 border rounded-md cursor-pointer transition">500</label>
                    </div>
                </div>
                <div>
                    <label class="font-bold text-slate-700">Effet du traitement (sur le risque) :</label>
                    <div class="flex flex-wrap gap-2 mt-2">
                        <input type="radio" name="effect_size" value="1.0" id="eff_none" class="control-radio hidden"><label for="eff_none" class="px-3 py-1 border rounded-md cursor-pointer transition">Aucun</label>
                        <input type="radio" name="effect_size" value="0.7" id="eff_weak" class="control-radio hidden" checked><label for="eff_weak" class="px-3 py-1 border rounded-md cursor-pointer transition">Faible</label>
                        <input type="radio" name="effect_size" value="0.4" id="eff_strong" class="control-radio hidden"><label for="eff_strong" class="px-3 py-1 border rounded-md cursor-pointer transition">Fort</label>
                    </div>
                </div>
            </div>
            <p class="text-sm text-center mt-4 text-slate-500">Le graphique ci-dessous représente chaque patient par une ligne. La longueur de la ligne indique la durée de son suivi.</p>
            <div class="mt-2"><canvas id="patient-lines-chart"></canvas></div>
            <div class="mt-2 p-4 bg-slate-100 rounded-md">
                 <p class="text-slate-600">Analyser à un temps fixe en comparant des risques d'événement est simple mais incomplet. Déplacez le curseur ci-dessous pour changer le "moment de la photo". Observez comment le nombre de patients inclus dans l'analyse, les résultats et la p-value changent radicalement en fonction du temps choisi.</p>
                 <label for="time-slider" class="font-bold block mt-2">Temps d'analyse : <span class="text-purple-700 font-mono time-value">18</span> mois</label>
                 <input type="range" id="time-slider" min="0" max="36" value="18" step="1" class="w-full mt-2 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
            </div>
            <div class="mt-6 grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200"><h3 class="text-lg font-bold text-center mb-4">Analyse au temps <span class="time-value font-mono">18</span></h3><div id="stats-result" class="text-center"></div></div>
                <div class="space-y-4"><h3 class="text-lg font-bold text-center">Proportions à l'analyse</h3><canvas id="event-rate-chart"></canvas><canvas id="lost-to-follow-up-chart" class="mt-4"></canvas></div>
            </div>
            <div class="mt-8 text-right"><button onclick="showNext('kaplan-meier-section')" class="px-5 py-2 bg-slate-700 text-white font-semibold rounded-md hover:bg-slate-800 transition">Passer à l'Analyse de Survie Complète →</button></div>
        </section>

        <section id="kaplan-meier-section" class="bg-white p-6 rounded-lg shadow-lg hidden-section">
            <h2 class="text-2xl font-bold text-teal-700 border-b-2 border-teal-100 pb-2">2. La Courbe de Kaplan-Meier (Population Totale)</h2>
            <p class="mt-4 text-slate-600">Au lieu d'analyser les patients à un temps fixe sous forme d'un critère binaire, l'analyse de survie va étudier <b>le temps mis par les patients jusqu'à présenter l'événement</b>. Pour utiliser toute l'information, on construit une courbe de survie "en escalier" à partir de l'estimateur de Kaplan-Meier pour la population entière. On part de 100%, puis la probabilité de survie ne diminue qu'au moment précis où un événement survient. Les petites barres verticales (|) sur la courbe indiquent les temps de censure : ces patients ne font pas chuter la courbe, mais sont retirés du calcul pour les temps futurs. La médiane de survie (temps où 50% des patients ont survécu) est indiquée par les lignes pointillées. La zone ombrée représente l'intervalle de confiance à 95%.</p>
            <div class="mt-4"><canvas id="km-chart-single"></canvas></div>
            <div class="mt-2 p-4 bg-slate-100 rounded-md">
                <label for="km-time-slider-single" class="font-bold">Explorer le temps : <span id="km-time-value-single" class="text-teal-700 font-mono">0</span> mois</label>
                <input type="range" id="km-time-slider-single" min="0" max="36" value="0" step="1" class="w-full mt-2 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
            </div>
            <div id="km-stats-single" class="mt-4 p-4 grid grid-cols-1 md:grid-cols-3 text-center bg-teal-50 border border-teal-200 rounded-md"></div>
            <div class="mt-8 text-right"><button onclick="showNext('km-group-comparison-section')" class="px-5 py-2 bg-teal-600 text-white font-semibold rounded-md hover:bg-teal-700 transition">Comparer les Groupes →</button></div>
        </section>

        <section id="km-group-comparison-section" class="bg-white p-6 rounded-lg shadow-lg hidden-section">
            <h2 class="text-2xl font-bold text-teal-700 border-b-2 border-teal-100 pb-2">3. Comparaison des Groupes par Kaplan-Meier</h2>
            <p class="mt-4 text-slate-600">La véritable puissance de cette méthode est de comparer les courbes entre les groupes. On peut maintenant tracer une courbe pour chaque groupe afin de comparer visuellement leur pronostic. Un écart entre les courbes suggère un effet du traitement. Le bouton ci-dessous permet de voir les données en termes d'incidence cumulative (1 - Survie), ce qui est parfois plus adapté pour représenter le risque d'événement, comme un infarctus.</p>
            <div class="mt-6 flex justify-center items-center gap-4">
                <label class="font-bold">Afficher :</label>
                <button id="toggle-survival" class="px-4 py-2 toggle-btn-active rounded-md">Survie</button>
                <button id="toggle-incidence" class="px-4 py-2 toggle-btn-inactive rounded-md">Incidence Cumulative</button>
            </div>
            <div class="mt-4"><canvas id="km-chart-groups"></canvas></div>
            <div class="mt-2 p-4 bg-slate-100 rounded-md">
                <label for="km-time-slider-groups" class="font-bold">Explorer le temps : <span id="km-time-value-groups" class="text-teal-700 font-mono">0</span> mois</label>
                <input type="range" id="km-time-slider-groups" min="0" max="36" value="0" step="1" class="w-full mt-2 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
            </div>
            <div class="mt-8 text-right"><button onclick="showNext('log-rank-comparison')" class="px-5 py-2 bg-slate-700 text-white font-semibold rounded-md hover:bg-slate-800 transition">Passer au Test Statistique →</button></div>
        </section>

        <section id="log-rank-comparison" class="bg-white p-6 rounded-lg shadow-lg hidden-section">
            <h2 class="text-2xl font-bold text-sky-700 border-b-2 border-sky-100 pb-2">4. Comparaison statistique : le test du Log-Rank</h2>
            <p class="mt-4 text-slate-600">L'inspection visuelle ne suffit pas. Le test du Log-Rank est le test statistique classique pour déterminer si l'écart entre les deux courbes est significatif ou simplement dû au hasard. Il compare, à chaque temps d'événement, le nombre de cas observés dans chaque groupe au nombre de cas attendus si le traitement n'avait aucun effet. Une p-value &lt;0.05 indique que la différence observée est statistiquement significative.</p>
             <div class="mt-6 grid grid-cols-1 lg:grid-cols-2 gap-8">
                 <div class="bg-slate-50 p-4 rounded-lg">
                     <h3 class="text-lg font-bold text-center">Comparaison des Courbes</h3>
                     <canvas id="log-rank-chart"></canvas>
                 </div>
                 <div>
                     <div id="log-rank-result" class="p-4 bg-sky-100 border border-sky-200 rounded-md text-center"></div>
                     <h3 class="text-lg font-bold mt-6">Tableau Observé vs. Attendu</h3>
                     <p class="text-sm text-slate-500">Ce tableau résume le nombre total d'événements observés et attendus (calculés sur l'ensemble des temps d'événements).</p>
                     <div id="log-rank-table" class="mt-2"></div>
                 </div>
            </div>
            <div class="mt-8 text-right"><button onclick="showNext('cox-model-section')" class="px-5 py-2 bg-sky-600 text-white font-semibold rounded-md hover:bg-sky-700 transition">Aller plus loin avec le Modèle de Cox →</button></div>
        </section>

        <section id="cox-model-section" class="bg-white p-6 rounded-lg shadow-lg hidden-section">
            <h2 class="text-2xl font-bold text-rose-700 border-b-2 border-rose-100 pb-2">5. Quantification de l'Effet : le Modèle de Cox</h2>
            <p class="mt-4 text-slate-600">Le test du Log-Rank nous dit s'il existe une différence significative entre les courbes de survie, mais il ne quantifie pas l'<b>ampleur de l'effet</b> du traitement ou du facteur de risque. Pour cela, on utilise le <b>modèle de régression de Cox</b>. Ce modèle estime le <b>Hazard Ratio (HR)</b>, qui représente le rapport des risques instantanés d'événement entre les deux groupes.
            <br>
            - Un <b>HR &lt; 1</b> indique que le traitement/facteur de risque réduit le risque d'événement.
            <br>
            - Un <b>HR > 1</b> indique que le traitement/facteur de risque augmente le risque d'événement.
            <br>
            - Un <b>HR = 1</b> indique une absence d'effet.
            </p>
            <div id="cox-model-result" class="mt-6 p-6 bg-rose-50 border border-rose-200 rounded-lg text-center"></div>
            <div class="mt-6 p-4 bg-slate-100 rounded-md text-slate-700">
                <h3 class="font-bold text-lg">Au-delà de la comparaison de deux groupes</h3>
                <p class="mt-2">Par rapport à un test du Log rank, le modèle de Cox a plusieurs avantages:</p>
                <ul class="list-disc list-inside mt-2 space-y-1">
                    <li>Il peut analyser l'effet d'une <b>variable continue</b> (ex: l'âge, une valeur biologique) sur la survie, ce qui est impossible avec le Log-Rank qui ne compare que des groupes.</li>
                    <li>Il permet des <b>analyses multivariées</b> pour ajuster l'effet du traitement sur d'autres facteurs de confusion (ex: âge, sexe, comorbidités) et ainsi isoler l'effet propre du traitement.</li>
                </ul>
            </div>
        </section>

    </main>
<script>
// ===================================================================================
// SETUP & PLUGINS
// ===================================================================================
const customCanvasDrawer = {
    id: 'customCanvasDrawer',
    afterDraw: (chart) => {
        const { ctx, scales: { x, y } } = chart;
        ctx.save();
        if (chart.canvas.id === 'patient-lines-chart') {
            chart.data.datasets.forEach((dataset) => {
                ctx.strokeStyle = dataset.borderColor; ctx.fillStyle = dataset.borderColor; ctx.lineWidth = 1.5;
                dataset.data.forEach((point) => {
                    if (!point.patient) return;
                    const yValue = y.getPixelForValue(point.y); const xStart = x.getPixelForValue(0); const xEnd = x.getPixelForValue(point.x);
                    ctx.beginPath(); ctx.moveTo(xStart, yValue); ctx.lineTo(xEnd, yValue); ctx.stroke();
                    const status = point.patient.status; ctx.lineWidth = 2;
                    if (status === 'Événement') { ctx.beginPath(); ctx.moveTo(xEnd - 4, yValue - 4); ctx.lineTo(xEnd + 4, yValue + 4); ctx.moveTo(xEnd + 4, yValue - 4); ctx.lineTo(xEnd - 4, yValue + 4); ctx.stroke(); } 
                    else if (status === 'Censuré') { ctx.beginPath(); ctx.moveTo(xEnd, yValue - 5); ctx.lineTo(xEnd, yValue + 5); ctx.stroke(); } 
                    else if (status === "Fin d'étude") { ctx.beginPath(); ctx.moveTo(xEnd - 6, yValue - 4); ctx.lineTo(xEnd, yValue); ctx.lineTo(xEnd - 6, yValue + 4); ctx.fill(); }
                });
            });
            const endLineX = x.getPixelForValue(STUDY_END_TIME);
            ctx.beginPath(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2; ctx.setLineDash([6, 3]); ctx.moveTo(endLineX, y.top); ctx.lineTo(endLineX, y.bottom); ctx.stroke();
            ctx.fillStyle = '#1e293b'; ctx.textAlign = 'center'; ctx.fillText("Fin d'étude", endLineX, y.top + 15); ctx.setLineDash([]);
            const analysisTime = document.getElementById('time-slider').value;
            const analysisLineX = x.getPixelForValue(analysisTime);
            ctx.beginPath(); ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 2; ctx.moveTo(analysisLineX, y.top); ctx.lineTo(analysisLineX, y.bottom); ctx.stroke();
            ctx.fillStyle = '#dc2626'; ctx.textAlign = 'center'; ctx.fillText("Analyse", analysisLineX, y.top + 15);
        } else if (chart.canvas.id === 'km-chart-single') {
            const kmData = kaplanMeierData.all;
            if (!kmData) { ctx.restore(); return; }
            if (kmData.median.time) {
                const medianX = x.getPixelForValue(kmData.median.time);
                const medianY = y.getPixelForValue(50);
                ctx.beginPath(); ctx.strokeStyle = 'grey'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
                ctx.moveTo(x.left, medianY); ctx.lineTo(medianX, medianY); ctx.lineTo(medianX, y.bottom);
                ctx.stroke(); ctx.setLineDash([]);
            }
            kmData.censoredTimes.forEach(time => {
                const point = [...kmData.table].reverse().find(p => p.time <= time);
                if (point) {
                    const censorX = x.getPixelForValue(time);
                    const censorY = y.getPixelForValue(point.survival * 100);
                    ctx.beginPath(); ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
                    ctx.moveTo(censorX, censorY - 5); ctx.lineTo(censorX, censorY + 5);
                    ctx.stroke();
                }
            });
            const timeSlider = document.getElementById('km-time-slider-single');
            const time = parseInt(timeSlider.value); const lineX = x.getPixelForValue(time);
            ctx.beginPath(); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
            ctx.moveTo(lineX, y.top); ctx.lineTo(lineX, y.bottom); ctx.stroke(); ctx.setLineDash([]);
        } else if (chart.canvas.id === 'km-chart-groups') {
            const timeSlider = document.getElementById('km-time-slider-groups');
            if (!timeSlider) { ctx.restore(); return; }
            const time = parseInt(timeSlider.value);
            const lineX = x.getPixelForValue(time);
            ctx.beginPath(); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
            ctx.moveTo(lineX, y.top); ctx.lineTo(lineX, y.bottom);
            ctx.stroke(); ctx.setLineDash([]);
        }
        ctx.restore();
    }
};
Chart.register(ChartDataLabels, customCanvasDrawer);
const TRAITE_COLOR = 'rgba(34, 211, 238, 0.8)'; const PLACEBO_COLOR = 'rgba(251, 146, 60, 0.8)';
let patientData = []; let kaplanMeierData = {}; let logRankResults = {};
const STUDY_END_TIME = 36;
const chartInstances = {};
function createOrUpdateChart(canvasId, type, data, options) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].data = data; chartInstances[canvasId].options = options; chartInstances[canvasId].update('none'); 
    } else {
        chartInstances[canvasId] = new Chart(ctx, { type, data, options });
    }
}

// ===================================================================================
// LOGIQUE PRINCIPALE
// ===================================================================================
function fullSimulationUpdate() {
    const n_patients = document.querySelector('input[name="n_patients"]:checked').value;
    const effect_size = document.querySelector('input[name="effect_size"]:checked').value;
    generatePatientData(parseInt(n_patients), parseFloat(effect_size));
    renderPatientLinesChart();
    updateSnapshotAnalysis();
    kaplanMeierData.all = calculateKaplanMeier(patientData);
    kaplanMeierData.traite = calculateKaplanMeier(patientData.filter(p => p.group === 'Traité'));
    kaplanMeierData.placebo = calculateKaplanMeier(patientData.filter(p => p.group === 'Placebo'));
    logRankResults = performLogRankTest();

    if (document.getElementById('kaplan-meier-section').style.display === 'block') {
        renderKMSingleChart();
    }
    if (document.getElementById('km-group-comparison-section').style.display === 'block') {
         const isIncidence = document.getElementById('toggle-incidence').classList.contains('toggle-btn-active');
         renderKMGroupChart(isIncidence ? 'incidence' : 'survival');
    }
    if (document.getElementById('log-rank-comparison').style.display === 'block') {
        renderLogRankSection();
    }
    if (document.getElementById('cox-model-section').style.display === 'block') {
        renderCoxModelSection();
    }
}
function generatePatientData(n_patients, effect_size) {
    patientData = [];
    for (let i = 1; i <= n_patients; i++) {
        const group = Math.random() < 0.5 ? 'Traité' : 'Placebo';
        const hazard_multiplier = group === 'Traité' ? effect_size : 1.0;
        const time_to_event = -Math.log(Math.random()) * 28 * (1 / hazard_multiplier);
        const time_to_censor = Math.random() * STUDY_END_TIME * 1.8;
        let final_time = Math.min(time_to_event, time_to_censor, STUDY_END_TIME);
        let status = 'Événement';
        if (Math.abs(final_time - STUDY_END_TIME) < 1e-5) status = "Fin d'étude";
        else if (final_time === time_to_censor) status = 'Censuré';
        patientData.push({ id: i, group: group, time: final_time, status: status });
    }
}
function renderPatientLinesChart() {
    const datasets = { 'Traité': { data: [], borderColor: TRAITE_COLOR }, 'Placebo': { data: [], borderColor: PLACEBO_COLOR } };
    let y_pos = patientData.length;
    patientData.sort((a,b) => a.group.localeCompare(b.group) || b.time - a.time).forEach(p => {
        if(datasets[p.group]) datasets[p.group].data.push({ x: p.time, y: y_pos, patient: p });
        y_pos--;
    });
    const chartData = Object.keys(datasets).map(key => ({
        label: key, data: datasets[key].data, borderColor: datasets[key].borderColor, pointRadius: 0
    }));
    createOrUpdateChart('patient-lines-chart', 'scatter', { datasets: chartData }, {
        plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => `Patient ${c.raw.patient.id} (${c.raw.patient.group}): ${c.raw.patient.status} à ${c.raw.patient.time.toFixed(1)} mois.` }}, datalabels: { display: false } },
        scales: { x: { type: 'linear', min: 0, max: STUDY_END_TIME + 1, title: { display: true, text: 'Temps (mois)' } }, y: { display: false, min: 0, max: patientData.length + 1 } }
    });
}
function updateSnapshotAnalysis() {
    const analysisTime = parseInt(document.getElementById('time-slider').value);
    document.querySelectorAll('.time-value').forEach(el => el.textContent = analysisTime);
    if(chartInstances['patient-lines-chart']) chartInstances['patient-lines-chart'].update('none');
   
    const totalTraite = patientData.filter(p => p.group === 'Traité').length;
    const lostBeforeTraite = patientData.filter(p => p.group === 'Traité' && p.status === 'Censuré' && p.time < analysisTime).length;
    const denominatorTraite = totalTraite - lostBeforeTraite;
    const numeratorTraite = patientData.filter(p => p.group === 'Traité' && p.status === 'Événement' && p.time <= analysisTime).length;

    const totalPlacebo = patientData.filter(p => p.group === 'Placebo').length;
    const lostBeforePlacebo = patientData.filter(p => p.group === 'Placebo' && p.status === 'Censuré' && p.time < analysisTime).length;
    const denominatorPlacebo = totalPlacebo - lostBeforePlacebo;
    const numeratorPlacebo = patientData.filter(p => p.group === 'Placebo' && p.status === 'Événement' && p.time <= analysisTime).length;

    const rateTraite = denominatorTraite > 0 ? numeratorTraite / denominatorTraite : 0;
    const ratePlacebo = denominatorPlacebo > 0 ? numeratorPlacebo / denominatorPlacebo : 0;
   
    let rr, ci_low, ci_high, p_value;
    const a = numeratorTraite, b = denominatorTraite - numeratorTraite, c = numeratorPlacebo, d = denominatorPlacebo - numeratorPlacebo;

    if (denominatorTraite === 0 || denominatorPlacebo === 0 || a < 0 || b < 0 || c < 0 || d < 0) {
        rr = ci_low = ci_high = NaN; p_value = 1.0;
    } else {
        const rate_a = a / (a + b); const rate_c = c / (c + d);
        if (a === 0 || c === 0) {
            rr = ((a + 0.5) / (a + b + 0.5)) / ((c + 0.5) / (c + d + 0.5));
        } else {
            rr = rate_a / rate_c;
        }
        const logRR = Math.log(rr); 
        const seLogRR = Math.sqrt(1/(a+0.5) - 1/(a+b+0.5) + 1/(c+0.5) - 1/(c+d+0.5));
        ci_low = Math.exp(logRR - 1.96 * seLogRR);
        ci_high = Math.exp(logRR + 1.96 * seLogRR);
        const z = logRR / seLogRR;
        // Simple approximation for Normal CDF
        const standardNormalCdf = (z) => 0.5 * (1 + Math.sign(z) * Math.sqrt(1 - Math.exp(-2 * z * z / Math.PI)));
        p_value = 2 * (1 - standardNormalCdf(Math.abs(z)));
    }
   
    document.getElementById('stats-result').innerHTML = `
        <div class="space-y-4 text-sm">
            <div><h4 class="font-bold text-cyan-700">Risque Groupe Traité</h4><p class="font-mono text-lg">${(rateTraite * 100).toFixed(1)}%</p><p class="text-xs font-mono">(${numeratorTraite} événements / ${denominatorTraite} à risque)</p></div>
            <div><h4 class="font-bold text-orange-500">Risque Groupe Placebo</h4><p class="font-mono text-lg">${(ratePlacebo * 100).toFixed(1)}%</p><p class="text-xs font-mono">(${numeratorPlacebo} événements / ${denominatorPlacebo} à risque)</p></div>
        </div>
        <hr class="my-4"><div class="space-y-2">
            <div class="text-lg">Risque Relatif (RR) : <span class="font-bold font-mono">${isFinite(rr) ? rr.toFixed(2) : "N/A"}</span></div>
            <div class="text-sm">IC 95% : [<span class="font-mono">${isFinite(ci_low) ? ci_low.toFixed(2) : "N/A"}</span> ; <span class="font-mono">${isFinite(ci_high) ? ci_high.toFixed(2) : "N/A"}</span>]</div>
            <div class="text-sm">p-value (Z-test) : <span class="font-mono">${isFinite(p_value) ? p_value.toFixed(3) : "N/A"}</span></div>
        </div>`;
   
    createOrUpdateChart('event-rate-chart', 'bar', {
        labels: ['Traité', 'Placebo'], datasets: [{ data: [rateTraite*100, ratePlacebo*100], backgroundColor: [TRAITE_COLOR, PLACEBO_COLOR] }]
    }, { plugins: { legend: { display: false }, datalabels: { anchor: 'center', align: 'center', color: '#1e293b', font: { weight: 'bold'}, formatter: (v) => `${v.toFixed(1)}%` }, title: {display: true, text: "% d'événements parmi les patients à risque"} }, scales: { y: { min: 0, max: 100, ticks: {callback: (v) => v + '%'} } } });
    createOrUpdateChart('lost-to-follow-up-chart', 'bar', {
        labels: ['Traité', 'Placebo'], datasets: [{ data: [(totalTraite > 0 ? lostBeforeTraite/totalTraite : 0)*100, (totalPlacebo > 0 ? lostBeforePlacebo/totalPlacebo : 0)*100], backgroundColor: ['#9ca3af', '#9ca3af'] }]
    }, { plugins: { legend: { display: false }, datalabels: { anchor: 'center', align: 'center', color: '#1e293b', font: { weight: 'bold'}, formatter: (v) => `${v.toFixed(1)}%` }, title: {display: true, text: "% de perdus de vue cumulés"} }, scales: { y: { min: 0, max: 100, ticks: {callback: (v) => v + '%'} } } });
}

// ===================================================================================
// LOGIQUE POUR LA PARTIE 2, 3, 4 & 5
// ===================================================================================
function calculateKaplanMeier(dataSubset) {
    if(!dataSubset || dataSubset.length === 0) return { table: [], median: { time: null, ci: [null, null]}, censoredTimes: [] };
    const sortedData = [...dataSubset].sort((a,b) => a.time - b.time);
    let kmTable = [{ time: 0, survival: 1, se: 0, lower_ci: 1, upper_ci: 1 }];
    let survival = 1.0, greenwoodSum = 0;
    const allTimes = [...new Set(sortedData.map(p => p.time))].sort((a, b) => a-b);
    let at_risk = sortedData.length;
    for (const t of allTimes) {
        const events_at_t = sortedData.filter(p => p.time === t && p.status === 'Événement').length;
        const censored_at_t = sortedData.filter(p => p.time === t && p.status !== 'Événement').length;
        if(events_at_t > 0 && at_risk > 0 && (at_risk - events_at_t) !== 0) {
            greenwoodSum += events_at_t / (at_risk * (at_risk - events_at_t));
        }
        survival = at_risk > 0 ? survival * (1 - events_at_t / at_risk) : survival;
        const se = survival * Math.sqrt(greenwoodSum);
        const ci_half_width = 1.96 * se;
        kmTable.push({ time: t, survival: survival, se: se, lower_ci: Math.max(0, survival - ci_half_width), upper_ci: Math.min(1, survival + ci_half_width) });
        at_risk -= (events_at_t + censored_at_t);
    }
    let medianInfo = { time: null, ci: [null, null] };
    const medianEntry = kmTable.find(p => p.survival < 0.5 + 1e-9);
    if(medianEntry) {
        medianInfo.time = medianEntry.time;
        const se_at_median = medianEntry.se;
        if (se_at_median > 0 && medianEntry.survival > 0) {
            const log_se = se_at_median / (medianEntry.survival * Math.abs(Math.log(medianEntry.survival)));
            const ci_half_width = 1.96 * log_se;
            medianInfo.ci = [medianEntry.time * Math.exp(-ci_half_width), medianEntry.time * Math.exp(ci_half_width)];
        }
    }
    return { table: kmTable, median: medianInfo, censoredTimes: sortedData.filter(p => p.status === 'Censuré').map(p => p.time) };
}

function renderKMSingleChart() {
    const kmAll = kaplanMeierData.all;
    if (!kmAll) return;
    const createChartPoints = (kmData, valueKey) => {
        const data = [{x: 0, y: 1}];
        kmData.table.forEach((point) => { const lastPoint = data[data.length - 1]; if (lastPoint.x !== point.time) data.push({ x: point.time, y: lastPoint.y }); data.push({ x: point.time, y: point[valueKey] }); });
        const lastKmPoint = data[data.length - 1]; if (lastKmPoint && lastKmPoint.x < STUDY_END_TIME) data.push({ x: STUDY_END_TIME, y: lastKmPoint.y });
        return data.map(p => ({...p, y: p.y * 100}));
    };
    let datasets = [
        { label: 'IC 95% Upper', data: createChartPoints(kmAll, 'upper_ci'), fill: 1, backgroundColor: 'rgba(71, 85, 105, 0.2)', borderColor: 'transparent', pointRadius: 0, stepped: 'before' },
        { label: 'Survie', data: createChartPoints(kmAll, 'survival'), borderColor: '#475569', backgroundColor: '#475569', stepped: 'before', pointRadius: 0, fill: false },
        { label: 'IC 95% Lower', data: createChartPoints(kmAll, 'lower_ci'), fill: '-1', backgroundColor: 'rgba(71, 85, 105, 0.2)', borderColor: 'transparent', pointRadius: 0, stepped: 'before' },
    ];
    createOrUpdateChart('km-chart-single', 'line', { datasets }, {
        scales: { x: { type: 'linear', min: 0, max: STUDY_END_TIME, title: { display: true, text: 'Temps (mois)' } }, y: { min: 0, max: 100, title: { display: true, text: 'Probabilité de survie (%)' }, ticks: {callback: (v) => v + '%'} } },
        plugins: { legend: { display: false }, datalabels: { display: false }, tooltip: { enabled: false } }
    });
    updateKMSingleStats(parseInt(document.getElementById('km-time-slider-single').value));
}

function updateKMSingleStats(time) {
    document.getElementById('km-time-value-single').textContent = time;
    const chart = chartInstances['km-chart-single']; if (chart) chart.update('none'); 
    const kmAll = kaplanMeierData.all; if (!kmAll || !kmAll.table || kmAll.table.length === 0) return;
    const pointInTime = [...kmAll.table].reverse().find(p => p.time <= time) || kmAll.table[0];
    const n_at_risk_t = patientData.filter(p => p.time >= time).length;
    const n_events_t = patientData.filter(p => p.status === 'Événement' && p.time <= time).length;
    const n_censored_t = patientData.filter(p => p.status === 'Censuré' && p.time <= time).length;
    document.getElementById('km-stats-single').innerHTML = `
        <div><h4 class="font-bold text-sm">Médiane de Survie</h4><p class="font-mono text-lg">${kmAll.median.time ? kmAll.median.time.toFixed(1) + ' mois' : 'Non atteinte'}</p><p class="text-xs">IC 95%: [${kmAll.median.ci[0] ? kmAll.median.ci[0].toFixed(1) : 'N/A'} ; ${kmAll.median.ci[1] ? kmAll.median.ci[1].toFixed(1) : 'N/A'}]</p></div>
        <div><h4 class="font-bold text-sm">Survie à ${time} mois</h4><p class="font-mono text-lg">${(pointInTime.survival * 100).toFixed(1)}%</p><p class="text-xs">IC 95%: [${(pointInTime.lower_ci * 100).toFixed(1)}% ; ${(pointInTime.upper_ci * 100).toFixed(1)}%]</p></div>
        <div><h4 class="font-bold text-sm">Activité jusqu'à ${time} mois</h4><p class="font-mono text-lg">${n_at_risk_t} à risque</p><p class="text-xs">${n_events_t} événements, ${n_censored_t} censurés</p></div>
    `;
}

function renderKMGroupChart(displayMode = 'survival') {
    const createChartPoints = (kmData, valueKey) => {
        const data = [{x: 0, y: 1}];
        if(!kmData.table) return [];
        kmData.table.forEach((point) => { const lastPoint = data[data.length - 1]; if (lastPoint.x !== point.time) data.push({ x: point.time, y: lastPoint.y }); data.push({ x: point.time, y: point[valueKey] }); });
        const lastKmPoint = data[data.length - 1]; if (lastKmPoint && lastKmPoint.x < STUDY_END_TIME) data.push({ x: STUDY_END_TIME, y: lastKmPoint.y });
        return data.map(p => ({...p, y: p.y * 100}));
    };
    let datasets = [
        { label: 'Traité', data: createChartPoints(kaplanMeierData.traite, 'survival'), borderColor: TRAITE_COLOR, backgroundColor: TRAITE_COLOR, stepped: 'before', pointRadius: 0, fill: false },
        { label: 'Placebo', data: createChartPoints(kaplanMeierData.placebo, 'survival'), borderColor: PLACEBO_COLOR, backgroundColor: PLACEBO_COLOR, stepped: 'before', pointRadius: 0, fill: false }
    ];
    let yAxisTitle = 'Probabilité de survie (%)';
    if(displayMode === 'incidence') {
        yAxisTitle = 'Incidence cumulative (%)';
        datasets.forEach(ds => { ds.data = ds.data.map(p => ({...p, y: 100 - p.y})); });
    }
    createOrUpdateChart('km-chart-groups', 'line', { datasets }, {
        scales: { x: { type: 'linear', min: 0, max: STUDY_END_TIME, title: { display: true, text: 'Temps (mois)' } }, y: { min: 0, max: 100, title: { display: true, text: yAxisTitle }, ticks: {callback: (v) => v + '%'} } },
        plugins: { legend: { position: 'bottom' }, datalabels: { display: false }, tooltip: { enabled: true, mode: 'index', intersect: false } }
    });
    updateKMGroupTooltip(parseInt(document.getElementById('km-time-slider-groups').value));
}

function updateKMGroupTooltip(time) {
    document.getElementById('km-time-value-groups').textContent = time;
    const chart = chartInstances['km-chart-groups']; if (chart) chart.update('none'); 
}

function performLogRankTest() {
    const allEventsTimes = [...new Set(patientData.filter(p => p.status === 'Événement').map(p => p.time))].sort((a,b) => a-b);
    let O_minus_E_sum = 0, variance_sum = 0;
    let O_traite_total = 0, E_traite_total = 0, O_placebo_total = 0, E_placebo_total = 0;
    for (const t of allEventsTimes) {
        const at_risk_total = patientData.filter(p => p.time >= t).length;
        const at_risk_traite = patientData.filter(p => p.group === 'Traité' && p.time >= t).length;
        const events_total = patientData.filter(p => p.time === t && p.status === 'Événement').length;
        if (at_risk_total < 2) continue;
        const O_traite = patientData.filter(p => p.time === t && p.status === 'Événement' && p.group === 'Traité').length;
        const E_traite = events_total * (at_risk_traite / at_risk_total);
        O_traite_total += O_traite;
        E_traite_total += E_traite;
        O_placebo_total += (events_total - O_traite);
        E_placebo_total += events_total * (1 - at_risk_traite / at_risk_total);
        O_minus_E_sum += (O_traite - E_traite);
        if (at_risk_total > 1) {
            const variance_t = (events_total * at_risk_traite * (at_risk_total - at_risk_traite) * (at_risk_total - events_total)) / (Math.pow(at_risk_total, 2) * (at_risk_total - 1));
            variance_sum += variance_t;
        }
    }
    const chi2 = variance_sum > 0 ? Math.pow(O_minus_E_sum, 2) / variance_sum : 0;
    const p_value = Math.exp(-0.5 * chi2); // Approximation for Chi2 distribution with 1 df
    return { chi2, p_value, O_minus_E_sum, variance_sum, O_traite: O_traite_total, E_traite: E_traite_total, O_placebo: O_placebo_total, E_placebo: E_placebo_total };
}

function renderLogRankSection() {
    document.getElementById('log-rank-result').innerHTML = `
        <h3 class="text-lg font-bold">Résultat du Test Log-Rank</h3>
        <p class="text-3xl font-mono mt-2">${logRankResults.p_value < 0.001 ? "p < 0.001" : `p ≈ ${logRankResults.p_value.toFixed(3)}`}</p>
        <p class="text-xs">(Statistique du Chi² = ${logRankResults.chi2.toFixed(2)})</p>
        <p class="mt-2 ${logRankResults.p_value < 0.05 ? 'text-green-600' : 'text-red-600'}">${logRankResults.p_value < 0.05 ? 'Différence statistiquement significative.' : 'Pas de différence statistiquement significative.'}</p>
    `;
    document.getElementById('log-rank-table').innerHTML = `
        <table class="w-full text-center">
            <thead class="bg-slate-200"><tr><th>Groupe</th><th class="p-2">Observé (O)</th><th class="p-2">Attendu (E)</th></tr></thead>
            <tbody>
                <tr class="border-b"><td class="p-2 font-bold text-cyan-700">Traité</td><td>${logRankResults.O_traite}</td><td>${logRankResults.E_traite.toFixed(1)}</td></tr>
                <tr class="border-b"><td class="p-2 font-bold text-orange-500">Placebo</td><td>${logRankResults.O_placebo}</td><td>${logRankResults.E_placebo.toFixed(1)}</td></tr>
            </tbody>
        </table>`;
    const createChartPoints = (kmData, valueKey) => {
        const data = [{x: 0, y: 1}];
        if(!kmData.table) return [];
        kmData.table.forEach((point) => { const lastPoint = data[data.length - 1]; if (lastPoint.x !== point.time) data.push({ x: point.time, y: lastPoint.y }); data.push({ x: point.time, y: point[valueKey] }); });
        const lastKmPoint = data[data.length - 1]; if (lastKmPoint && lastKmPoint.x < STUDY_END_TIME) data.push({ x: STUDY_END_TIME, y: lastKmPoint.y });
        return data.map(p => ({...p, y: p.y * 100}));
    };
    let datasets = [
        { label: 'Traité', data: createChartPoints(kaplanMeierData.traite, 'survival'), borderColor: TRAITE_COLOR, backgroundColor: TRAITE_COLOR, stepped: 'before', pointRadius: 0, fill: false },
        { label: 'Placebo', data: createChartPoints(kaplanMeierData.placebo, 'survival'), borderColor: PLACEBO_COLOR, backgroundColor: PLACEBO_COLOR, stepped: 'before', pointRadius: 0, fill: false }
    ];
    createOrUpdateChart('log-rank-chart', 'line', { datasets }, {
        scales: { x: { type: 'linear', min: 0, max: STUDY_END_TIME, title: { display: true, text: 'Temps (mois)' } }, y: { min: 0, max: 100, title: { display: true, text: 'Probabilité de survie (%)' }, ticks: {callback: (v) => v + '%'} } },
        plugins: { legend: { position: 'bottom' }, datalabels: { display: false }, tooltip: { enabled: true } }
    });
}

function performCoxModel() {
    const { O_minus_E_sum, variance_sum } = logRankResults;
    if (variance_sum <= 0) {
        return { hr: NaN, ci_low: NaN, ci_high: NaN, p_value: NaN };
    }
    // Approximation du coefficient beta et du HR à partir des résultats du Log-Rank.
    // C'est une approche valide et pédagogique pour une seule variable de groupe.
    const beta = O_minus_E_sum / variance_sum; 
    const hr = Math.exp(beta);
    const se_beta = Math.sqrt(1 / variance_sum);
    const ci_low = Math.exp(beta - 1.96 * se_beta);
    const ci_high = Math.exp(beta + 1.96 * se_beta);
   
    // Pour une seule variable binaire, la p-value du test de Wald (Cox) est
    // asymptotiquement équivalente à la p-value du test du Log-Rank.
    const p_value = logRankResults.p_value; 

    return { hr, ci_low, ci_high, p_value };
}

function renderCoxModelSection() {
    const coxResults = performCoxModel();
    const logRank_p = logRankResults.p_value;

    document.getElementById('cox-model-result').innerHTML = `
        <h3 class="text-lg font-bold">Résultat du Modèle de Cox</h3>
        <div class="mt-4">
            <p class="text-xl">Hazard Ratio (HR)</p>
            <p class="text-4xl font-mono font-bold mt-1 ${coxResults.hr < 1 ? 'text-green-600' : 'text-red-600'}">${isFinite(coxResults.hr) ? coxResults.hr.toFixed(2) : 'N/A'}</p>
        </div>
        <div class="mt-4 text-slate-700">
            <p>IC 95% : <span class="font-mono">[${isFinite(coxResults.ci_low) ? coxResults.ci_low.toFixed(2) : 'N/A'} ; ${isFinite(coxResults.ci_high) ? coxResults.ci_high.toFixed(2) : 'N/A'}]</span></p>
            <p class="mt-1">p-value : <span class="font-mono">${isFinite(coxResults.p_value) ? (coxResults.p_value < 0.001 ? "p < 0.001" : `p ≈ ${coxResults.p_value.toFixed(3)}`) : 'N/A'}</span></p>
        </div>
        <div class="mt-6 pt-4 border-t border-rose-200">
            <h4 class="font-semibold">Comparaison avec le Log-Rank</h4>
            <p class="text-sm mt-1">La p-value du modèle de Cox est très similaire à celle du test du Log-Rank (p ≈ ${logRank_p.toFixed(3)}). C'est normal : pour une seule variable de groupe, les deux tests évaluent la même hypothèse. Le modèle de Cox nous donne en plus une estimation de la <b>force de l'association</b> (le HR).</p>
        </div>
    `;
}

// ===================================================================================
// GESTION DES ÉVÉNEMENTS
// ===================================================================================
window.onload = () => {
    document.querySelectorAll('input[name="n_patients"], input[name="effect_size"]').forEach(radio => { radio.addEventListener('change', fullSimulationUpdate); });
    document.getElementById('time-slider').addEventListener('input', updateSnapshotAnalysis);
    document.getElementById('km-time-slider-single').addEventListener('input', (e) => updateKMSingleStats(parseInt(e.target.value)));
    document.getElementById('km-time-slider-groups').addEventListener('input', (e) => updateKMGroupTooltip(parseInt(e.target.value)));
    const survivalBtn = document.getElementById('toggle-survival');
    const incidenceBtn = document.getElementById('toggle-incidence');
    survivalBtn.addEventListener('click', () => { renderKMGroupChart('survival'); survivalBtn.classList.replace('toggle-btn-inactive', 'toggle-btn-active'); incidenceBtn.classList.replace('toggle-btn-active', 'toggle-btn-inactive'); });
    incidenceBtn.addEventListener('click', () => { renderKMGroupChart('incidence'); incidenceBtn.classList.replace('toggle-btn-inactive', 'toggle-btn-active'); survivalBtn.classList.replace('toggle-btn-active', 'toggle-btn-inactive'); });
    fullSimulationUpdate();
};

function showNext(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
        section.style.display = 'block';
        if (!section.hasAttribute('data-simulated')) {
            if (sectionId === 'kaplan-meier-section') renderKMSingleChart(); 
            if (sectionId === 'km-group-comparison-section') renderKMGroupChart();
            if (sectionId === 'log-rank-comparison') renderLogRankSection();
            if (sectionId === 'cox-model-section') renderCoxModelSection();
            section.setAttribute('data-simulated', 'true');
        }
        setTimeout(() => { section.classList.add('visible-section'); section.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 50);
    }
}
</script>
</body>
</html>
